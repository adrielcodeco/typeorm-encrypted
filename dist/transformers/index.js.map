{"version":3,"sources":["../../src/transformers/index.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,aAAa,EAA0B,MAAM,SAAS,CAAA;AAgE/D,gCAAwB,CAAC,SAAS,aAAa,EAAG,MAAM,EAAE,CAAC,GAAG,CAAC,CAe9D;AAKD,gCAAwB,CAAC,SAAS,aAAa,EAAG,MAAM,EAAE,CAAC,GAAG,CAAC,CAe9D","file":"index.js","sourcesContent":["import { ObjectLiteral, getMetadataArgsStorage } from 'typeorm'\nimport { createCipheriv, createDecipheriv } from 'crypto'\nimport { ExtendedColumnOptions } from '../options'\n\nconst BufferCompatibility = (array: any[]) => {\n  if (Buffer.from) {\n    return Buffer.from(array)\n  } else {\n    // tslint:disable-next-line: deprecation\n    return new Buffer(array)\n  }\n}\n\nfunction convertCryptKey (strKey: any) {\n  const newKey: any = BufferCompatibility([\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0\n  ])\n  strKey = BufferCompatibility(strKey)\n  for (let i = 0; i < strKey.length; i++) newKey[i % 16] ^= strKey[i]\n  return newKey\n}\n\nconst _encrypt = (str: string, key: string) => {\n  try {\n    const c = createCipheriv('aes-128-ecb', convertCryptKey(key), '')\n    let ret = ''\n    ret += c.update(str, 'utf8', 'hex')\n    ret += c.final('hex')\n    return ret.toUpperCase()\n  } catch (err) {\n    return str\n  }\n}\n\nconst _decrypt = (str: string, key: string) => {\n  try {\n    const d = createDecipheriv('aes-128-ecb', convertCryptKey(key), '')\n    let ret = ''\n    ret += d.update(str, 'hex', 'utf8')\n    ret += d.final('utf8')\n    return ret\n  } catch (err) {\n    return str\n  }\n}\n\n/**\n * Encrypt fields on entity.\n */\nexport function encrypt<T extends ObjectLiteral> (entity: T): T {\n  for (let columnMetadata of getMetadataArgsStorage().columns) {\n    let { propertyName, mode, target } = columnMetadata\n    let options: ExtendedColumnOptions = columnMetadata.options\n    let encrypt = options.encryptKey\n    if (encrypt && mode === 'regular' && entity.constructor === target) {\n      if (entity[propertyName]) {\n        entity[propertyName] = _encrypt(\n          entity[propertyName],\n          encrypt + (options.name || propertyName)\n        )\n      }\n    }\n  }\n  return entity\n}\n\n/**\n * Decrypt fields on entity.\n */\nexport function decrypt<T extends ObjectLiteral> (entity: T): T {\n  for (let columnMetadata of getMetadataArgsStorage().columns) {\n    let { propertyName, mode, target } = columnMetadata\n    let options: ExtendedColumnOptions = columnMetadata.options\n    let encrypt = options.encryptKey\n    if (encrypt && mode === 'regular' && entity.constructor === target) {\n      if (entity[propertyName]) {\n        entity[propertyName] = _decrypt(\n          entity[propertyName],\n          encrypt + (options.name || propertyName)\n        )\n      }\n    }\n  }\n  return entity\n}\n"]}